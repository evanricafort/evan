<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORS Misconfiguration Scanner</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
        }
        .container {
            width: 80%;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        .log-container {
            margin-top: 20px;
            background-color: #222;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            height: 300px;
            overflow-y: auto;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            font-size: 16px;
        }
        .vuln {
            background-color: #ff4d4d;
            color: white;
        }
        .warn {
            background-color: #ffcc00;
            color: black;
        }
        .ok {
            background-color: #4caf50;
            color: white;
        }
        .error {
            background-color: #f44336;
            color: white;
        }
        .noCORS {
            background-color: #f1f1f1;
            color: black;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CORS Misconfiguration Scanner</h1>

        <label for="url">Target URL:</label>
        <input type="text" id="url" placeholder="Enter target URL" style="width: 100%; padding: 10px;">
        
        <label for="origin">Origin URL:</label>
        <input type="text" id="origin" placeholder="Enter Origin URL" style="width: 100%; padding: 10px;">
        
        <label for="method">HTTP Method (GET, POST, etc.):</label>
        <input type="text" id="method" placeholder="Enter HTTP Method" value="GET" style="width: 100%; padding: 10px;">

        <button onclick="startScan()">Start Scan</button>

        <div id="scanResult"></div>

        <div class="log-container" id="logContainer"></div>
    </div>

    <script>
        const log = (message) => {
            const logContainer = document.getElementById('logContainer');
            logContainer.textContent += message + '\n';
            logContainer.scrollTop = logContainer.scrollHeight;
        };

        const resultDetails = {
            vuln: {
                message: "üî¥ Vulnerable: Wildcard Origin or Exploitable CORS Misconfiguration",
                explanation: `
A vulnerable CORS configuration has been identified. This means that the target server has either:
- Allowed all origins by setting 'Access-Control-Allow-Origin' to '*' (Wildcard).
- Reflected the origin back and allowed credentials, which may allow attackers to perform Cross-Site Request Forgery (CSRF) or steal sensitive data (such as cookies) from authenticated users.

Attackers can exploit this by making unauthorized API calls from malicious sites or stealing sensitive data from the user‚Äôs session.

**Recommendation:**
- Restrict CORS to a specific set of trusted origins.
- Avoid sending sensitive data to a wildcard origin or allowing credentials with CORS headers.
                `
            },
            warn: {
                message: "üü† Warning: Reflective Origin Detected, Credentials Not Allowed",
                explanation: `
A reflective origin has been detected, which indicates that the target server is vulnerable to potential cross-origin attacks. However, credentials (cookies, session) are not accepted.

While this may not be as critical as an issue with wildcard origins or credentials acceptance, this still poses a risk. Attackers could potentially exploit the reflected CORS origin to launch social engineering attacks or gain insight into the server's CORS configuration.

If sensitive information is included in the response headers, or if the endpoint is capable of manipulating user data, this could escalate into a significant issue.

**Recommendation:**
- Restrict the CORS policy to specific origins.
- Consider adding the `Access-Control-Allow-Credentials` header only for trusted origins.
                `
            },
            ok: {
                message: "üü¢ Safe: Proper CORS Configuration Detected",
                explanation: `
The target server has a proper CORS configuration in place. The 'Access-Control-Allow-Origin' header reflects a specific, trusted origin, and credentials are either not required or not allowed.

This indicates that the server is not vulnerable to cross-origin attacks, such as Cross-Site Request Forgery (CSRF) or unauthorized data access from malicious websites.

This is a positive outcome, but the security posture can be further strengthened by ensuring sensitive endpoints have stricter CORS policies or other security mechanisms like Anti-CSRF tokens.

**Recommendation:**
- Continue enforcing a restrictive CORS policy.
- Ensure that all sensitive data and authentication tokens are protected against unauthorized cross-origin access.
                `
            },
            error: {
                message: "‚ùå Error: Scan Failed or Misconfigured",
                explanation: `
The scan encountered an issue during execution. This could be due to a misconfigured URL, server failure, or unexpected CORS behavior. This result may also be indicative of network issues or incorrect configuration in the CORS headers.

While this doesn't indicate a direct vulnerability, it does highlight that the test couldn't be completed successfully for this particular URL. It's important to ensure the URL is reachable and the server is properly configured to handle CORS preflight and actual requests.

**Recommendation:**
- Verify the URL and check if the server is properly configured to handle OPTIONS requests (preflight) and the expected method (GET, POST, etc.).
- Investigate the server logs for any issues that may have prevented the scan from completing.
                `
            },
            noCORS: {
                message: "‚ö™ No CORS Headers Found",
                explanation: `
No CORS headers were returned for the target endpoint. This typically indicates that the server is configured to block cross-origin requests entirely, which is a good security practice for public APIs or endpoints that shouldn't be accessible from other origins.

While this reduces the attack surface for cross-origin attacks, it‚Äôs also important to ensure that the server is not unintentionally rejecting legitimate requests that need to access the resources from different origins.

**Recommendation:**
- If the endpoint is meant to be accessed cross-origin, make sure the correct CORS headers are configured.
- If the server intentionally blocks cross-origin requests, verify that no functionality is broken as a result.
                `
            }
        };

        async function startScan() {
            const url = document.getElementById('url').value;
            const origin = document.getElementById('origin').value;
            const method = document.getElementById('method').value;

            if (!url || !origin || !method) {
                alert("Please enter a URL, Origin, and HTTP Method.");
                return;
            }

            log(`Starting scan on ${url} with method ${method} and origin ${origin}`);
            const result = await checkCORS(url, origin, method);
            displayResult(result);
        }

        async function checkCORS(url, origin, method) {
            try {
                log(`\nüåê Scanning ${url} using ${method}`);
                const preflightHeaders = {
                    "Origin": origin,
                    "Access-Control-Request-Method": method
                };

                // Preflight OPTIONS
                log(`OPTIONS ${url}`);
                const optionsRes = await fetch(url, {
                    method: "OPTIONS",
                    headers: preflightHeaders
                });
                log(`OPTIONS Status: ${optionsRes.status}`);
                optionsRes.headers.forEach((v, k) => log(`  ${k}: ${v}`));

                // Actual request
                const actualRes = await fetch(url, {
                    method: method,
                    headers: {
                        "Origin": origin
                    },
                    mode: "cors",
                    body: ["POST", "PUT", "PATCH"].includes(method) ? "data=test" : undefined
                });

                const ao = actualRes.headers.get("Access-Control-Allow-Origin");
                const ac = actualRes.headers.get("Access-Control-Allow-Credentials");
                const status = actualRes.status;
                log(`\n${method} ${url}`);
                log(`Status: ${status}`);
                log(`Access-Control-Allow-Origin: ${ao}`);
                log(`Access-Control-Allow-Credentials: ${ac}`);

                let resultStatus, resultNotes;

                // Check for wildcard origin
                if (ao === "*") {
                    resultStatus = "vuln";
                    resultNotes = resultDetails.vuln.explanation;
                }
                // Check for allowed origin and credentials
                else if (ao === origin && ac === "true") {
                    resultStatus = "vuln";
                    resultNotes = resultDetails.vuln.explanation;
                } else if (ao === origin) {
                    resultStatus = "warn";
                    resultNotes = resultDetails.warn.explanation;
                } else if (ao) {
                    resultStatus = "ok";
                    resultNotes = resultDetails.ok.explanation;
                } else {
                    resultStatus = "noCORS";
                    resultNotes = resultDetails.noCORS.explanation;
                }

                return { status: resultStatus, notes: resultNotes };
            } catch (err) {
                log(`‚ùå Error: ${err.message}`);
                return {
                    status: "error",
                    notes: resultDetails.error.explanation
                };
            }
        }

        function displayResult(result) {
            const resultDiv = document.getElementById("scanResult");
            const statusClass = result.status;
            resultDiv.innerHTML = `
                <div class="result ${statusClass}">
                    <h3>${resultDetails[statusClass].message}</h3>
                    <p>${result.notes}</p>
                </div>
            `;
        }
    </script>
</body>
</html>
